Constraint Programming en GPROLOG
=================================

* Definir un problema de CP consisteix en:

  (1) Definir quines variables es faran servir i el seu significat

  (2) Determinar el domini de les variables

  (3) Establir les restriccions entre les variables


* Els programes en CP són bàsicament la definició del problema. En GNU
  Prolog, els programes tenen la següent estructura:

  (a) Definició dels dominis de les variables

  (b) Declaració de les restriccions entre les variables

  (c) Generació de solucions


* Exemple 1: problema de les 8 reines ( = tauler d'escacs)

  Donat un tauler quadrat amb 8x8 caselles, disposar 8 reines sense
  que es matin entre elles.

  * A cada columna no pot haver-hi dues reines, i per tant podem
  assignar files a columnes. La variable Xi és la fila corresponent a
  la columna i.

  * Cadascuna d'aquestes variables pot prendre valors entre 1 i 8
  (les files possibles)

  * Les restriccions sobre aquestes variables són:

    * Xi != Xj si i < j               (no n'hi ha 2 a la mateixa fila)

    * Xi != Xj - (j - i),             (no n'hi ha 2 a la mateixa diagonal)
      Xi != Xj + (j - i)  si i < j

    La línia de (a, b) a (a', b') és paral·lela a (1, 1)  sii
    (a' - a, b' - b) és múltiple de (1, 1)                sii
    a' - a = s = b' - b                                   sii
    b = b' - (a' - a)

    La línia de (a, b) a (a', b') és paral·lela a (1, -1) sii
    (a' - a, b' - b) és múltiple de (1, -1)               sii
    a' - a = s = b - b'                                   sii
    b = b' + (a' - a)

    (la restricció que no hi ha dues reines en una mateixa
    columna es satisfà per la formalització)

  * Programa Prolog que resol això:

reines :-
	L = [X1, X2, X3, X4, X5, X6, X7, X8],
%	L = [_, _, _, _, _, _, _, _],

        % Molts dels predicats de GPROLOG per fer constraint
        % programming comencen per fd_ (de *f*inite *d*omain).

	fd_domain(L, 1, 8), <---- defineix dominis de variables
	segur(L),           <---- estableix les restriccions
	fd_labeling(L),     <---- genera solucions
        write(L),           <---- escriu solucions
        nl.

segur([]).
segur([X|L]) :-
	no_ataca(X, L, 1),
	segur(L).

no_ataca(_, [], _).
no_ataca(X, [Y|L], I) :-
	X #\= Y,             <--- X i Y són diferents
	X #\= Y + I,         <--- X i Y + I són diferents
	X #\= Y - I,         <--- X i Y - I són diferents
	J is I + 1,
	no_ataca(X, L, J).

* Exemple 2: sudokus

  Donat un tauler quadrat 9x9, es tracta d'omplir-lo amb xifres de 1
  a 9 de manera que no hi hagi xifres repetides en cap fila, en cap
  columna ni en cap quadrat 3x3. A més, algunes de les caselles ja tenen
  assignada la xifra que els pertoca.

  * Les variables són Xij, que representen la xifra a la casella de
    la fila i, columna j.

  * Les variables Xij poden prendre valors entre 1 i 9 (les xifres)

  * Les restriccions són que les Xij pertinents siguin diferents a cada

  fila        (f 1 -> X11, X12, X13, X14, X15, X16, X17, X18, X19)
  columna     (c 1 -> X11, X21, X31, X41, X51, X61, X71, X81, X91)
  quadrat 3x3 (1,1 -> X11, X21, X31, X12, X22, X32, X13, X23, X33)

  + concordança amb les caselles ja plenes


  * Programa Prolog que resol això:

exemple :- sudoku([5,3,_,_,7,_,_,_,_,
		   6,_,_,1,9,5,_,_,_,
		   _,9,8,_,_,_,_,6,_,
		   8,_,_,_,6,_,_,_,3,
		   4,_,_,8,_,3,_,_,1,
		   7,_,_,_,2,_,_,_,6,
		   _,6,_,_,_,_,2,8,_,
		   _,_,_,4,1,9,_,_,5,
		   _,_,_,_,8,_,_,7,9]).
sudoku(L) :-
	L = [X11, X12, X13, X14, X15, X16, X17, X18, X19,
	     X21, X22, X23, X24, X25, X26, X27, X28, X29,
	     X31, X32, X33, X34, X35, X36, X37, X38, X39,
	     X41, X42, X43, X44, X45, X46, X47, X48, X49,
	     X51, X52, X53, X54, X55, X56, X57, X58, X59,
	     X61, X62, X63, X64, X65, X66, X67, X68, X69,
	     X71, X72, X73, X74, X75, X76, X77, X78, X79,
	     X81, X82, X83, X84, X85, X86, X87, X88, X89,
	     X91, X92, X93, X94, X95, X96, X97, X98, X99],

        % Es defineixen els dominis de les variables.
	fd_domain(L, 1, 9),

        % Es donen les restriccions.
        %
        % fd_all_different(L) força a que les variables de la llista L
        % siguin totes diferents entre sí.
        %
        % Files.
	fd_all_different([X11,X12,X13,X14,X15,X16,X17,X18,X19]),
	fd_all_different([X21,X22,X23,X24,X25,X26,X27,X28,X29]),
	fd_all_different([X31,X32,X33,X34,X35,X36,X37,X38,X39]),
	fd_all_different([X41,X42,X43,X44,X45,X46,X47,X48,X49]),
	fd_all_different([X51,X52,X53,X54,X55,X56,X57,X58,X59]),
	fd_all_different([X61,X62,X63,X64,X65,X66,X67,X68,X69]),
	fd_all_different([X71,X72,X73,X74,X75,X76,X77,X78,X79]),
	fd_all_different([X81,X82,X83,X84,X85,X86,X87,X88,X89]),
	fd_all_different([X91,X92,X93,X94,X95,X96,X97,X98,X99]),

        % Columnes.
	fd_all_different([X11,X21,X31,X41,X51,X61,X71,X81,X91]),
	fd_all_different([X12,X22,X32,X42,X52,X62,X72,X82,X92]),
	fd_all_different([X13,X23,X33,X43,X53,X63,X73,X83,X93]),
	fd_all_different([X14,X24,X34,X44,X54,X64,X74,X84,X94]),
	fd_all_different([X15,X25,X35,X45,X55,X65,X75,X85,X95]),
	fd_all_different([X16,X26,X36,X46,X56,X66,X76,X86,X96]),
	fd_all_different([X17,X27,X37,X47,X57,X67,X77,X87,X97]),
	fd_all_different([X18,X28,X38,X48,X58,X68,X78,X88,X98]),
	fd_all_different([X19,X29,X39,X49,X59,X69,X79,X89,X99]),

        % Quadrats 3x3.
	fd_all_different([X11,X21,X31,X12,X22,X32,X13,X23,X33]),
	fd_all_different([X14,X24,X34,X15,X25,X35,X16,X26,X36]),
	fd_all_different([X17,X27,X37,X18,X28,X38,X19,X29,X39]),
	fd_all_different([X41,X51,X61,X42,X52,X62,X43,X53,X63]),
	fd_all_different([X44,X54,X64,X45,X55,X65,X46,X56,X66]),
	fd_all_different([X47,X57,X67,X48,X58,X68,X49,X59,X69]),
	fd_all_different([X71,X81,X91,X72,X82,X92,X73,X83,X93]),
	fd_all_different([X74,X84,X94,X75,X85,X95,X76,X86,X96]),
	fd_all_different([X77,X87,X97,X78,X88,X98,X79,X89,X99]),

        % Es generen els candidats a solucions.
	fd_labeling(L),

        % S'escriu la solució.
	pinta(L).

pinta(L):- pinta_aux(L, 9).
pinta_aux([], _).
pinta_aux(L, 0):- L\=[],  nl,  pinta_aux(L, 9).
pinta_aux([X|L], N):-
	N>0,  write(X),  write(' '),
	N1 is N-1,  pinta_aux(L, N1).


* Estructura dels programes Prolog en Constraint Programming

  1) Es defineixen les variables i els dominis on prenen valors
     (fd_domain)

  2) Es donen les restriccions sobre aquestes variables
     (fd_all_different, #\=, ...)

  3) Es generen candidats a solucions
     (fd_labeling)



1) Definició de variables i dels dominis on prenen valors
---------------------------------------------------------

  Variables FD en GPROLOG
  -----------------------

* GPROLOG té un tipus especial de variables, les variables FD (Finite
  Domain), que només poden prendre valors en els dominis respectius.

* Per defecte, el domini d'una variable FD és 0..fd_max_integer
  (fd_max_integer es pot consultar fent fd_max_integer(X)). De tota
  manera, és una bona pràctica declarar el domini de cada variable FD.

* Les variables FD no poden prendre valors negatius.

* Les variables FD són compatibles amb els enters i amb variables
  Prolog normals (per aquest motiu no cal declarar-les de manera
  especial).

* Durant l'execució del programa, el domini d'una variable FD es va
  reduint pas a pas gràcies a les restriccions.

* Les variables FD es representen de dues maneres diferents:

  1) Representació amb interval: només es guarda el mínim i el màxim
     dels dominis de les variables.
     És possible guardar dominis inclosos en 0..fd_max_integer.
     (en el meu GPROLOG, fd_max_integer = 268435455)

  2) Representació esparsa: es guarda un vector de bits que permet
     guardar exactament el domini.
     És possible guardar dominis inclosos en 0..vector_max.
     (per defecte, vector_max és 127)
     Aquest valor es pot canviar mitjançant fd_set_vector_max.

* En general, la representació inicial per a una variable FD és la
  representació amb intervals, i es canvia a una representació esparsa
  quan es fa un ``forat'' en el domini.

* Una vegada una variable es representa de forma esparsa, ja no es
  representa amb intervals, tot i que el domini pot no contenir forats
  a partir d'un cert moment.

* Quan es produeix el canvi de representació de la variable FD X es
  pot produir pèrdua de solucions perquè vector_max << fd_max_integer.
  Quan una restricció no es pot satisfer possiblement degut a pèrdua
  de solucions, es sol produir el missatge
  "Warning: Vector too small - maybe lost solutions"
  De tota manera, pot haver-hi situacions que hi hagi pèrdua de
  solucions i no es detecti.

| ?- fd_domain(X,[1,2, 250]), fd_labeling(X), write(X).
1

X = 1 ? ;
2

X = 2 ? ;
Warning: Vector too small - maybe lost solutions (FD Var:_2)
no
         --------------------------------------------

 | ?- fd_set_vector_max(255), fd_domain(X,[1,2, 250]), fd_labeling(X), write(X).
1

X = 1 ? ;
2

X = 2 ? ;
250

X = 250

yes


* Els vectors de bits utilitzats en la representació dels dominis són
  estàtics, no dinàmics. Per tant, fd_set_vector_max s'ha de cridar
  abans d'usar cap constraint.


  Definició de dominis
  --------------------

  fd_domain(Vars, Lower, Upper) restringeix cada element X de la
                                llista Vars a prendre un valor entre
                                Lower i Upper (inclosos).
                                Vars pot ser una sola variable.

  fd_domain(Vars, Values)       restringeix cada element X de la
                                llista Vars a prendre un valor dins de
                                la llista Values.
                                Vars pot ser una sola variable.
                                S'utilitza representació esparsa.



2) Declaració de les restriccions
---------------------------------

Les restriccions tenen com a component bàsic les expressions
aritmètiques.

* Expressions aritmètiques

  Una expressió aritmètica FD és un terme Prolog construït a partir
  d'enters, variables i functors que representen funcions
  aritmètiques.  Les expressions compostes són del tipus:

      -  E
  E1  +  E2
  E1  -  E2
  E1  *  E2
  E1 **  E2     E1 elevat a E2
  min(E1, E2)
  max(E1, E2)
  dist(E1, E2)  |E1 - E2|
  E1 //  E2     divisió entera de E1 entre E2
  E1 rem E2     residu de E1 entre E2


A partir de les expressions aritmètiques, es poden construir
restriccions aritmètiques.

* Restriccions aritmètiques

  E1 #=  E2   força a que E1 sigui igual    a E2
  E1 #\= E2   força a que E1 sigui diferent a E2
  E1 #<  E2    ...
  E1 #>  E2
  E1 #=< E2
  E1 #>= E2

* Altres restriccions aritmètiques (que no utilitzen expressions aritmètiques):

  fd_prime(X)     força X a    ser un nombre primer
  fd_not_prime(X) força X a no ser un nombre primer


Les restriccions es poden composar amb operadors booleans per formar
restriccions més complexes.

* Restriccions booleanes

  0             fals
  1             cert
  #\ E          no E
  E1 #/\   E2   E1 and  E2
  E1 #\/   E2   E1 or   E2
  E1 #==>  E2   E1 implica E2
  E1 #<=>  E2   E1 equivalent a E2
  E1 #\<=> E2   E1 diferent de E2

De vegades convé forçar a que el nombre de restriccions que es fan
certes sigui un cert nombre.

* Restriccions de cardinalitat

fd_cardinality(L, Count)  unifica Count amb el nombre de
                          restriccions que són certes a L.

fd_cardinality(Lo, L, Up) equival a
                          fd_cardinality(L, C), Lo #=< C, C #=< Up

fd_at_least_one(L)        equival a fd_cardinality(L, C), C #>= 1
fd_at_most_one(L)         equival a fd_cardinality(L, C), C #<= 1
fd_only_one(L)            equival a fd_cardinality(L, 1)


* Altres restriccions:

fd_all_different(List)    força a que totes les variables de List
			  preguin valors diferents.

fd_element(I, L, X)       força a que X sigui igual al I-èsim element
                          (començant per 1) de la llista d'enters L

fd_element_var(I, L, X)   força a que X sigui igual al I-èsim element
                          (començant per 1) de la llista L, que pot
                          contenir variables.

fd_atmost(N, L, V)        com a molt  N variables de L són iguals a V
fd_atleast(N, L, V)       com a mínim N variables de L són iguals a V
fd_exactly(N, L, V)       exactament  N variables de L són iguals a V



3) Generació de candidats a solucions (etiquetatge)
---------------------------------------------------

fd_labeling(Vars, Opts) assigna un valor a cada variable X de la
llista Vars d'acord amb la llista d'opcions Opts. Vars pot ser una
sola variable. Aquest predicat és reexecutable sota backtracking.

Opcions:

  * variable_method(Opt): especifica l'heurística per a seleccionar la
  següent variable que serà instanciada. Opt pot ser:

     - standard: la de més a l'esquerra

     - first_fail: selecciona la que té menys elements en el domini.
     En cas d'empat, selecciona la de més a l'esquerra.

     - most_constrained: com l'anterior, però
     en cas d'empat escull la variable que surt en més restriccions.

     - smallest: selecciona la variable amb valor més petit en el domini.
     En cas d'empat, escull la que surt en més restriccions.

     - largest : selecciona la variable amb valor més gran en el domini.
     En cas d'empat, escull la que surt en més restriccions.

     - max_regret: selecciona la variable amb la diferència més gran
     entre el valor més petit i el valor més gran en el seu domini.
     En cas d'empat, escull la que surt en més restriccions.

  * reorder(true/false): especifica si l'heurística pot reordenar
    dinàmicament l'ordre de les variables (true) o no (false).

  * value_method(Opt): especifica l'heurística per escollir el valor a
    assignar a la següent variable. Opt pot ser:

    - min   : del més petit al més gran
    - max   : del més gran al més petit
    - middle: del mig cap als extrems
    - bounds: dels extrems cap al mig
    - random: aleatòriament (cada valor es prova una sola vegada)



Optimització
------------

  fd_minimize(Goal, X) repetidament crida Goal per trobar un valor que
  minimitza la variable X. Goal és un objectiu de Prolog que instancia
  X, normalment mitjançant fd_labeling.







| ?- fd_domain([X,Y], 1,5), X #\= Y, S #= X + Y,
     fd_minimize(fd_labeling([X,Y,S], []), S), write([X,Y]), nl, fail.

[1,2]
[2,1]

(1 ms) no

  Aquest predicat utilitza un algorisme de branch-and-bound: cada
  vegada call(Goal) té èxit un nou càlcul comença amb la nova
  restricció X#< V, on V és el valor de X al final de la darrera crida
  a Goal. Quan es falla (sigui perquè ja no hi ha més alternatives,
  sigui perquè la restricció afegida és inconsistent amb la resta de
  restriccions), la darrera solució és recalculada, ja que és
  l'óptima.

  fd_maximize fa el mateix, però maximitzant.
